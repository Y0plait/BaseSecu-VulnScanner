"""
@file vulnerability_checker.py
@brief Vulnerability scanning and reporting module

This module handles the complete vulnerability assessment workflow:
- Querying the NVD API for vulnerabilities associated with CPEs
- Error handling for API rate limits, timeouts, and invalid CPEs
- Generating and saving JSON vulnerability reports
- Tracking vulnerability statistics

@author Anton Moulin
@date 2025-12-24
@version 1.0

@details
Implements rate-limit aware API calls with graceful degradation for:
- Network timeouts (503 errors)
- API rate limits (429 errors)
- Invalid CPEs (404 errors)
"""

import time
import logging

from src.caching import cache_db
from src.acquisition import pkg_finder
from src.reporting import output_formatter as fmt
from src.reporting import report_generator as report

logger = logging.getLogger(__name__)


def check_vulnerabilities(packages_cpes, machine, api_key, api_delay, component_type="software"):
    """
    Query NVD API for vulnerabilities associated with machine's CPEs.
    
    Iterates through all CPE identifiers for a machine and queries the NVD
    database for associated vulnerabilities. Implements rate limiting,
    error handling, and result caching.
    
    @param packages_cpes dict Mapping of packages/components to CPE lists
                              Format: {package_name: [cpe_string_1, ...]}
    @param machine str Machine name for logging and error reporting
    @param api_key str NVD API key for authentication
    @param api_delay float Delay in seconds between API requests
    @param component_type str Type of component: "software" (default) or "hardware"
    
    @return tuple (vulnerabilities_found, machine_vulnerabilities)
            vulnerabilities_found int: Total CVEs found on machine
            machine_vulnerabilities dict: Structured vulnerability data
                Format: {cpe: [{cve_id, description}, ...], ...}
    
    @details
    - Uses cache_db.get_vulnerabilities() for optimized queries
    - Respects API rate limits with configurable delays
    - Stores vulnerability details for report generation
    - Handles errors gracefully without stopping processing
    - Supports both software packages and hardware components
    """
    fmt.print_info(f"Checking for {component_type} vulnerabilities...")
    logger.info(f"Starting {component_type} vulnerability check for {machine}")
    
    vulnerabilities_found = 0
    machine_vulnerabilities = {}  # Track vulnerabilities per CPE for report
    
    for package, cpe_list in packages_cpes.items():
        for cpe in cpe_list:
            try:
                logger.debug(f"Checking {component_type} vulnerabilities for CPE: {cpe}")
                vulns = cache_db.get_vulnerabilities(cpe_string=cpe, api_key=api_key)
                
                if vulns:
                    machine_vulnerabilities[cpe] = []
                
                for cve_id, desc in vulns:
                    vulnerabilities_found += 1
                    cve_url = report.generate_cve_url(cve_id)
                    logger.warning(f"{component_type.upper()} VULNERABILITY FOUND on {machine}: {cve_id} - {desc[:100]}")
                    fmt.print_vulnerability(cve_id, desc[:120], cve_url=cve_url)
                    
                    # Store vulnerability data for report
                    machine_vulnerabilities[cpe].append({
                        "cve_id": cve_id,
                        "description": desc
                    })
                
                # Throttle API requests to avoid rate limiting
                time.sleep(api_delay)

            except Exception as e:
                _handle_vulnerability_check_error(e, cpe, machine)
    
    return vulnerabilities_found, machine_vulnerabilities


def _handle_vulnerability_check_error(error, cpe, machine):
    """
    Handle errors encountered during vulnerability checking.
    
    Differentiates between various error types and applies appropriate
    handling strategies:
    - 404: CPE not found → Mark as invalid
    - 429: Rate limit → Wait and retry
    - 503: Service unavailable → Wait and retry
    - Other: Log and continue
    
    @param error Exception The error that occurred
    @param cpe str CPE string being checked
    @param machine str Machine name for logging
    
    @details
    - Only marks CPEs as invalid for actual 404 errors
    - Implements exponential backoff for rate limiting
    - Does not mark CPEs as invalid for transient failures
    """
    error_msg = str(error)
    
    # Only mark as invalid for actual 404 errors (CPE not found)
    if "404" in error_msg and "not found" in error_msg.lower():
        logger.warning(f"CPE not found in NVD (404): {cpe} - Marking as invalid")
        pkg_finder.mark_cpe_invalid(cpe)
        fmt.print_warning(f"CPE not found in NVD: {cpe}")
    # For rate limiting errors, don't mark as invalid, just log and continue
    elif "429" in error_msg or "rate" in error_msg.lower():
        logger.warning(f"NVD API rate limit reached. Waiting before retrying...")
        fmt.print_warning(f"API rate limit reached for {cpe}. Pausing requests...")
        time.sleep(5)  # Wait longer if rate limited
    elif "503" in error_msg or "timeout" in error_msg.lower():
        logger.warning(f"NVD API temporarily unavailable for {cpe}. Waiting...")
        fmt.print_warning(f"API temporarily unavailable. Waiting before retry...")
        time.sleep(3)
    else:
        logger.error(f"Error retrieving vulnerabilities for {cpe}: {error}")
        fmt.print_error(f"Error retrieving vulnerabilities for {cpe}: {error}")


def finalize_machine_report(machine, vulnerabilities_found, machine_vulnerabilities):
    """
    Finalize vulnerability assessment for a machine and generate report.
    
    Creates a JSON vulnerability report containing all found CVEs with their
    associated CPEs and detailed descriptions.
    
    @param machine str Machine name
    @param vulnerabilities_found int Total vulnerabilities discovered
    @param machine_vulnerabilities dict Structured vulnerability data
    
    @return int Total vulnerabilities count for statistics
    
    @details
    - Generates user-friendly output messages
    - Saves JSON report to machines/{machine}/vulnerability_report.json
    - Logs report generation for audit trail
    - Includes CVE.org URLs in reports for reference
    """
    if vulnerabilities_found == 0:
        fmt.print_success("No vulnerabilities found!")
        logger.info(f"No vulnerabilities found on {machine}")
        machine_vulnerabilities = {}  # Empty report
    else:
        fmt.print_warning(f"Found {vulnerabilities_found} vulnerabilities on this machine")
        logger.warning(f"Found {vulnerabilities_found} vulnerabilities on {machine}")
    
    # Generate and save vulnerability report for this machine
    report_file = report.save_machine_report(machine, machine_vulnerabilities)
    if report_file:
        fmt.print_success(f"Report saved to {report_file}")
        logger.info(f"Vulnerability report generated for {machine}")
    
    return vulnerabilities_found
