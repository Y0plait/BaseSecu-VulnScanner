<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VisualNet Scanner: src.acquisition.pkg_finder Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">VisualNet Scanner<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Comprehensive vulnerability scanner for Linux machines with network visualization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacesrc_1_1acquisition_1_1pkg__finder.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">src.acquisition.pkg_finder Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a78ac70f5df242579cec77032592e9020" id="r_a78ac70f5df242579cec77032592e9020"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78ac70f5df242579cec77032592e9020">get_installed_packages_linux</a> (loaded_config, machine_inventory_name)</td></tr>
<tr class="memitem:ad47c99a23be8edca7a510d6d98699850" id="r_ad47c99a23be8edca7a510d6d98699850"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad47c99a23be8edca7a510d6d98699850">get_hardware_info</a> (loaded_config, machine_inventory_name)</td></tr>
<tr class="memitem:aea660cfd6df09c5ba551cef55ae812ff" id="r_aea660cfd6df09c5ba551cef55ae812ff"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea660cfd6df09c5ba551cef55ae812ff">get_new_packages</a> (machine_inventory_name, current_installed_packages)</td></tr>
<tr class="memitem:a38a7b84de1cac8d8e71c8ef9cadb43c0" id="r_a38a7b84de1cac8d8e71c8ef9cadb43c0"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38a7b84de1cac8d8e71c8ef9cadb43c0">get_cached_cpes</a> (package_name)</td></tr>
<tr class="memitem:acc1fb763971899dd1f844ee7bc556695" id="r_acc1fb763971899dd1f844ee7bc556695"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc1fb763971899dd1f844ee7bc556695">cache_cpes</a> (packages_cpes_dict)</td></tr>
<tr class="memitem:ab2b16b1392ea60d9a682b612abdff95d" id="r_ab2b16b1392ea60d9a682b612abdff95d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2b16b1392ea60d9a682b612abdff95d">mark_cpe_invalid</a> (cpe_string)</td></tr>
<tr class="memitem:a41c3157f3cdda0a5a8703535d10d18bd" id="r_a41c3157f3cdda0a5a8703535d10d18bd"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41c3157f3cdda0a5a8703535d10d18bd">get_packages_needing_cpe_generation</a> (packages)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:add5a659c1554afaf1f79fe0937aa7e01" id="r_add5a659c1554afaf1f79fe0937aa7e01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add5a659c1554afaf1f79fe0937aa7e01">logger</a> = logging.getLogger(__name__)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@file pkg_finder.py
@brief Package retrieval, caching, and CPE matching module

Handles SSH-based package retrieval from remote Linux machines with intelligent
caching and sanitization. Implements two-level caching:
1. Per-machine package cache (detects new/removed packages)
2. Global CPE cache (avoids redundant AI/API queries)

Supports multiple Linux distributions:
- Debian/Ubuntu (apt package manager)
- Red Hat/Fedora/AlmaLinux (dnf package manager)
- Alpine Linux (apk package manager)

@author Anton Moulin
@date 2025-12-24
@version 1.0

@details
**Caching Strategy:**

Package Cache (per-machine):
- File: machines/{machine}/installed_packages.json
- Contains: Serialized list of all currently installed packages
- Purpose: Delta detection - identifies newly installed/removed packages
- Benefits: Avoids regenerating CPEs for unchanged packages

CPE Cache (global):
- File: machines/cpe_cache.json
- Contains: {package_name: [{"cpe": "cpe:...", "valid": true/false}, ...]}
- Purpose: Caches AI-generated CPEs and API-verified CPEs
- Benefits: Avoids regenerating CPEs across machine scans
- Validity Tracking: Marks 404 CPEs as invalid to skip API queries

**Sanitization Logic:**

Package managers output different formats:
- apt: "package/distribution version architecture [status]"
- dnf: "package.arch version repo"
- apk: "package-version"

Sanitization handles:
1. Detect format by checking for "/" (apt) or " " (dnf/apk)
2. Extract package name (before "/" or space)
3. Remove metadata like "[installed]"
4. Remove version information
5. Validate result is non-empty and starts with alphanumeric or dash

**SSH Connection:**

Requires SSH credentials from inventory.ini:
- host: IP address or hostname
- user: SSH username
- password: SSH password (or key-based auth via paramiko)

Auto-detects OS via /etc/os-release to choose package manager.
Gracefully handles connection failures and unknown distributions.
</pre> </div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="acc1fb763971899dd1f844ee7bc556695" name="acc1fb763971899dd1f844ee7bc556695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1fb763971899dd1f844ee7bc556695">&#9670;&#160;</a></span>cache_cpes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">src.acquisition.pkg_finder.cache_cpes </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>packages_cpes_dict</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cache newly generated CPEs to the global cache file.

@param packages_cpes_dict dict Mapping of {package_name: [cpe_string, ...]}

@details
**Caching Process:**
1. Load existing cache (machines/cpe_cache.json)
2. Merge new CPEs, wrapping each in validity object: {"cpe": "...", "valid": true}
3. Write updated cache back to file

**Cache Merging:**
New CPEs are merged with existing cache entries. If a package already exists
in cache, it will be updated (not appended to).

**File Format:**
Output is pretty-printed JSON for readability:
@code
{
    "curl": [
        {"cpe": "cpe:2.3:a:curl:curl:7.85.0:*:*:*:*:*:*:*", "valid": true},
        {"cpe": "cpe:2.3:a:curl:curl:7.85.1:*:*:*:*:*:*:*", "valid": true}
    ],
    "openssl": [...]
}
@endcode

**Error Handling:**
- Cache file missing: Creates new cache
- Corrupted JSON: Logs error and starts fresh
- File write errors: Logged but doesn't raise (attempts best effort)

**Storage Location:**
machines/cpe_cache.json (shared across all machine scans)

@note
This function should be called after ask_for_cpe() returns successfully
</pre> 
<p class="definition">Definition at line <a class="el" href="pkg__finder_8py_source.html#l00456">456</a> of file <a class="el" href="pkg__finder_8py_source.html">pkg_finder.py</a>.</p>

</div>
</div>
<a id="a38a7b84de1cac8d8e71c8ef9cadb43c0" name="a38a7b84de1cac8d8e71c8ef9cadb43c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a7b84de1cac8d8e71c8ef9cadb43c0">&#9670;&#160;</a></span>get_cached_cpes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list src.acquisition.pkg_finder.get_cached_cpes </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>package_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Retrieve cached CPEs for a package, filtering out invalid (404) entries.

@param package_name str Package name to look up in cache

@return list List of valid CPE strings for the package (empty if not cached)

@details
**Cache Lookup:**
1. Check if machines/cpe_cache.json exists
2. Load JSON and find package entry
3. Filter entries by validity flag
4. Return only valid CPEs (valid: true)

**Validity Tracking:**
CPE cache format:
@code
{
    "package_name": [
        {"cpe": "cpe:2.3:a:...", "valid": true},
        {"cpe": "cpe:2.3:a:...", "valid": false}
    ],
    ...
}
@endcode

Invalid CPEs (valid: false) are caused by NVD API 404 responses and indicate
that the package/version combination doesn't exist in vulnerability databases.
These are skipped to avoid redundant API queries.

**Cache Miss Behavior:**
- Cache file doesn't exist: Returns empty list
- Package not in cache: Returns empty list
- All entries marked invalid: Returns empty list (triggers regeneration)

**Backward Compatibility:**
Old cache format (strings instead of objects) is handled by treating
missing "valid" key as valid=true.

@note
Returned CPEs are ready to pass to vulnerability_checker.check_vulnerabilities()
</pre> 
<p class="definition">Definition at line <a class="el" href="pkg__finder_8py_source.html#l00384">384</a> of file <a class="el" href="pkg__finder_8py_source.html">pkg_finder.py</a>.</p>

</div>
</div>
<a id="ad47c99a23be8edca7a510d6d98699850" name="ad47c99a23be8edca7a510d6d98699850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47c99a23be8edca7a510d6d98699850">&#9670;&#160;</a></span>get_hardware_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict src.acquisition.pkg_finder.get_hardware_info </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>loaded_config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>machine_inventory_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Retrieve hardware information from a remote Linux machine via SSH using lscpu.

@param loaded_config dict Configuration dictionary (typically from ConfigParser)
@param machine_inventory_name str Machine name/identifier from inventory

@return dict Dictionary containing parsed hardware information with keys:
             - 'vendor_id': CPU vendor (Intel, AMD, etc.)
             - 'model_name': CPU model description
             - 'family': CPU family identifier
             - 'model': CPU model number
             - 'stepping': CPU stepping number
             - 'flags': Space-separated CPU flags/features
             - 'cores': Number of CPU cores
             - 'threads': Number of threads per core
             - 'raw_output': Complete lscpu output for reference

@details
Uses `lscpu` command to gather CPU information without elevated privileges.
Parses key:value format output commonly found on Linux systems.

Hardware CPE can be generated for vulnerabilities like:
- Spectre (CVE-2017-5753, CVE-2017-5715)
- Meltdown (CVE-2017-5754)
- RIDL/Zombieload (CVE-2019-11091)
- CPU errata and microcode issues

@note
Returns dict with all keys present but empty string if lscpu unavailable or fails.
This allows graceful degradation without stopping the scan.
</pre> 
<p class="definition">Definition at line <a class="el" href="pkg__finder_8py_source.html#l00214">214</a> of file <a class="el" href="pkg__finder_8py_source.html">pkg_finder.py</a>.</p>

</div>
</div>
<a id="a78ac70f5df242579cec77032592e9020" name="a78ac70f5df242579cec77032592e9020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ac70f5df242579cec77032592e9020">&#9670;&#160;</a></span>get_installed_packages_linux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list src.acquisition.pkg_finder.get_installed_packages_linux </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>loaded_config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>machine_inventory_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Retrieve installed packages from a remote Linux machine via SSH.

@param loaded_config dict Configuration dictionary (typically from ConfigParser)
@param machine_inventory_name str Machine name/identifier from inventory

@return list List of sanitized package names (all empty results filtered out)

@details
**Connection Process:**
1. Parse machine configuration (host, username, password)
2. Establish SSH connection using paramiko
3. Query /etc/os-release to detect OS type
4. Select appropriate package manager:
   - apt for Debian/Ubuntu
   - dnf for RedHat/Fedora/AlmaLinux
   - apk for Alpine Linux
5. Execute package listing command
6. Parse and sanitize output
7. Close SSH connection

**Sanitization:**
The sanitization pipeline handles the format differences:
@code
apt format:    package-name/distribution 1.2.3-4ubuntu1
dnf format:    package-name.arch 2.1.0-1.fc40
@endcode

Both formats are converted to just the package name.

**Error Handling:**
- Connection failures: Logged and returns empty list
- Unknown OS: Logged as warning, returns empty list
- SSH command errors: Logged as debug

@note
Configuration must include keys for the machine:
- config[machine_inventory_name]['host']
- config[machine_inventory_name]['user']
- config[machine_inventory_name]['password']

@throws paramiko.ssh_exception.* Exceptions are caught and logged, not re-raised
</pre> 
<p class="definition">Definition at line <a class="el" href="pkg__finder_8py_source.html#l00074">74</a> of file <a class="el" href="pkg__finder_8py_source.html">pkg_finder.py</a>.</p>

</div>
</div>
<a id="aea660cfd6df09c5ba551cef55ae812ff" name="aea660cfd6df09c5ba551cef55ae812ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea660cfd6df09c5ba551cef55ae812ff">&#9670;&#160;</a></span>get_new_packages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list src.acquisition.pkg_finder.get_new_packages </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>machine_inventory_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>current_installed_packages</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Detect packages that are newly installed since last scan.

@param machine_inventory_name str Machine identifier
@param current_installed_packages list Current packages from get_installed_packages_linux()

@return list Packages not present in previous cached state

@details
**Delta Detection Algorithm:**
1. Load previous package list from machines/{machine}/installed_packages.json
2. Create sets of current and previous packages
3. Compute set difference: current - previous = new packages
4. Also compute previous - current = removed packages (logged for awareness)
5. Return only new packages (unchanged packages are ignored)

**Caching Behavior:**
- First run: No cache exists, all packages returned as "new"
- Subsequent runs: Only truly new packages returned
- Cache file: machines/{machine}/installed_packages.json

**Benefits:**
- Avoids regenerating CPEs for packages that are unchanged
- Detects both added and removed packages (logs removed for awareness)
- Gracefully handles missing cache (first-time setup)

**File Format:**
Cache file is JSON array:
@code
["package1", "package2", "package3", ...]
@endcode

@note
After calling this function, machine_processor.py should update the cache
by calling save_package_cache(machine, current_installed_packages)
</pre> 
<p class="definition">Definition at line <a class="el" href="pkg__finder_8py_source.html#l00317">317</a> of file <a class="el" href="pkg__finder_8py_source.html">pkg_finder.py</a>.</p>

</div>
</div>
<a id="a41c3157f3cdda0a5a8703535d10d18bd" name="a41c3157f3cdda0a5a8703535d10d18bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c3157f3cdda0a5a8703535d10d18bd">&#9670;&#160;</a></span>get_packages_needing_cpe_generation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list src.acquisition.pkg_finder.get_packages_needing_cpe_generation </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>packages</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Filter packages to identify those without cached CPEs.

@param packages list List of package names to check

@return list Subset of packages that need CPE generation (not in cache)

@details
**Filtering Logic:**
1. For each package, call get_cached_cpes()
2. If cache returns empty list, package needs generation
3. If cache returns CPEs, skip generation
4. Return list of packages requiring generation

**Optimization:**
This function avoids regenerating CPEs for packages we've already processed.
On first run, all packages need generation. On subsequent runs, only new packages
are processed, significantly reducing API calls to Google GenAI.

**Return Value:**
If cache is 100% effective, this returns only new packages.
If cache is missing/corrupted, this returns all packages.

**Logging:**
Logs:
- Each package that needs generation (DEBUG level)
- Summary: "{count} packages need CPE generation out of {total}" (INFO)

Example output:
@code
packages: ["curl", "openssl", "git", "nano"]
cache: {"curl": [...], "nano": [...]}
result: ["openssl", "git"]  # Only these need generation
@endcode
</pre> 
<p class="definition">Definition at line <a class="el" href="pkg__finder_8py_source.html#l00583">583</a> of file <a class="el" href="pkg__finder_8py_source.html">pkg_finder.py</a>.</p>

</div>
</div>
<a id="ab2b16b1392ea60d9a682b612abdff95d" name="ab2b16b1392ea60d9a682b612abdff95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b16b1392ea60d9a682b612abdff95d">&#9670;&#160;</a></span>mark_cpe_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">src.acquisition.pkg_finder.mark_cpe_invalid </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>cpe_string</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Mark a CPE as invalid (404 response from NVD API) in the cache.

@param cpe_string str CPE identifier to mark as invalid

@details
**Why Mark CPEs Invalid?**
When NVD API returns HTTP 404 for a CPE, it means the CPE doesn't exist
in their database (invalid combination of vendor/product/version).

Marking as invalid:
- Prevents redundant API calls for non-existent packages
- Clearly distinguishes from temporary errors (429 rate limit, 503 unavailable)
- Maintains cache size by not querying known-invalid CPEs

**Implementation:**
1. Load machines/cpe_cache.json
2. Find the CPE in any package's entry
3. Set valid: false
4. Write cache back to disk

**Error Handling:**
- Cache file not found: Silently returns (nothing to invalidate)
- Corrupted JSON: Logs error and returns
- Write failures: Logged but doesn't raise

**Called From:**
vulnerability_checker.py when NVD API returns 404 status code.

@note
404 errors are different from 429/503 errors and should not cause
retries or backoff - they indicate the CPE is genuinely invalid.
</pre> 
<p class="definition">Definition at line <a class="el" href="pkg__finder_8py_source.html#l00523">523</a> of file <a class="el" href="pkg__finder_8py_source.html">pkg_finder.py</a>.</p>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="add5a659c1554afaf1f79fe0937aa7e01" name="add5a659c1554afaf1f79fe0937aa7e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5a659c1554afaf1f79fe0937aa7e01">&#9670;&#160;</a></span>logger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">src.acquisition.pkg_finder.logger = logging.getLogger(__name__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="pkg__finder_8py_source.html#l00067">67</a> of file <a class="el" href="pkg__finder_8py_source.html">pkg_finder.py</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacesrc.html">src</a></li><li class="navelem"><a href="namespacesrc_1_1acquisition.html">acquisition</a></li><li class="navelem"><a href="namespacesrc_1_1acquisition_1_1pkg__finder.html">pkg_finder</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for VisualNet Scanner by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
